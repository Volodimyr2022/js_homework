// const LOGIN = 'ADMIN';
// const PASSWORD = '1q2w3e';

// const authorize = () => {
//     let userPassword;
//     let userLogin;
//     do {
//         userLogin = prompt('Логин') 
//             if (!userLogin) {
//                 alert('Введите логин');
//             continue
//             };
//             userPassword = prompt('Пароль') 
//             if (!userLogin) {
//                 alert('Введите пароль');
//             continue
//             };
//             if (userPassword !== PASSWORD || userLogin !== LOGIN) {
//                 alert('Данные не верны');
//             continue
//             };
//             break;
//     }while(true)
//     alert('Welcome!')
// }
// authorize()


// const LOGIN = 'ADMIN';
// const PASSWORD = '1q2w3e';

// const authorize = () => {
//     let userPassword;
//     let userLogin;
//     let isAuthSuccess = false;

//     do {
//         userLogin = prompt('Логин:');
//             if (!userLogin) {
//                     alert('Введите логин');
//                     continue;
//                 }
            
//         userPassword = prompt('Пароль:'); 
//             if (!userLogin) {
//                     alert('Введите пароль');
//                     continue;
//                 }
//             if (userLogin === LOGIN && userPassword === PASSWORD) {
//                 isAuthSuccess = true;
//                 } else {
//                     alert('Данные не верны')
//                 };      
//         } while(!isAuthSuccess); 
//     alert('Welcome!');
// };
// authorize()

// const LOGIN = 'ADMIN';
// const PASSWORD = '1q2w3e';

// const authorize = () => {
//     let userPassword;
//     let userLogin;
//     let isAuthSuccess = false;
//     let attemptsLeft = 2;
//     let i = 0;
//     do {
//         userLogin = prompt('Логин:');
//             if (!userLogin) {
//                     alert('Введите логин');
//                     continue;
//                 }
            
//         userPassword = prompt('Пароль:'); 
//             if (!userLogin) {
//                     alert('Введите пароль');
//                     continue;
//                 }
//             if (userLogin === LOGIN && userPassword === PASSWORD) {
//                 isAuthSuccess = true;
//                 alert('Welcome!');
//                 } 
//                 else if (attemptsLeft > i) {
//                 alert(`Данные не верны у вас осталось ${attemptsLeft - i} попыток`)
//                     i++
//                 } else { 
//                     alert('Попытки закончились');
//                     break;
//                 }      
//         } while(!isAuthSuccess);
// };
// authorize()

let n =  100;

notSimple:
for (let i = 20; i <= n; i++) {

  for (let j = 2; j < i; j++) { 
    if (i % j == 0) continue notSimple;
    
  }
  console.log( i );
  
}

// ИТЕРАЦИЯ1
// 1. берём значение переменной і=20;
// 2. проверяем 20 <= 100 (условие выполняется, переходим во внутренний цикл);
// 3. берём значение переменной j=2;
// 4. проверяем 2 < 20 (условие выполняется, переходим к инструкции if)
// 5. выполняем проверку 20 % 2 == 0 это true и мы выполняем команду перехода на следующую 
// итерацию цикла с меткой notSimple: по директиве continue;
// 6. увеличиваем значение переменной і на единицу и теперь і=21;

// ИТЕРАЦИЯ2
// 1. берём значение переменной і=21;
// 2. проверяем 21 <= 100 (условие выполняется, переходим во внутренний цикл);
// 3. берём значение переменной j=2;
// 4. проверяем 2 < 21 (условие выполняется, переходим к инструкции if)
// 5. выполняем проверку 21 % 2 == 0 это false и мы НЕ выполняем команду перехода на следующую 
// итерацию цикла с меткой notSimple: по директиве continue, 

//  (ВОТ МОЙ ВОПРОС - ПО КАКОМУ ПУТИ НА ЭТОЙ РАЗВИЛКЕ ВЕДЁТ ИНСТРУКЦИЯ IF ЕСЛИ ЕЁ УСЛОВИЕ false
//  И ПОЧЕМУ? И ВООБЩЕ НА КАКИЕ УКАЗАНИЯ В КОДЕ НУЖНО ОБРАЩАТЬ ВНИМАНИЕ ЧТОБЫ ПРАВИЛЬНО ПОНИМАТЬ
// ПОТОК ВЫПОЛНЕНИЯ ЦИКЛА ;

//  далее (ПО МОЕМУ ПРЕДПОЛОЖЕНИЮ) мы остаёмся во внутреннем цикле (поскольку выполняются 
// все условия цикла) и увеличиваем значение j на  единицу и теперь j=3;

// 6. берём значение переменной j=3;  
// 7. проверяем 3 < 21 (условие выполняется, переходим к инструкции if);
// 8. выполняем проверку 21 % 3 == 0 это true и мы выполняем команду перехода на следующую 
// итерацию цикла с меткой notSimple: по директиве continue;
// 9. увеличиваем значение переменной і на единицу и теперь і=22;

// ИТЕРАЦИЯ3
// 1. берём значение переменной і=22;
// 2. проверяем 22 <= 100 (условие выполняется, переходим во внутренний цикл);
// 3. берём значение переменной j=2;
// 4. проверяем 2 < 22 (условие выполняется, переходим к инструкции if)
// 5. выполняем проверку 22 % 2 == 0 это true и мы выполняем команду перехода на следующую 
// итерацию цикла с меткой notSimple: по директиве continue;
// 6. увеличиваем значение переменной і на единицу и теперь і=23;

// ИТЕРАЦИЯ4
// 1. берём значение переменной і=23;
// 2. проверяем 23 <= 100 (условие выполняется, переходим во внутренний цикл);
// 3. берём значение переменной j=2;
// 4. проверяем 2 < 23 (условие выполняется, переходим к инструкции if)
// 5. выполняем проверку 23 % 2 == 0 это false и мы НЕ выполняем команду перехода на следующую 
// итерацию цикла с меткой notSimple: по директиве continue, а остаёмся во внутреннем цикле и
// увеличиваем значение j на единицу теперь j=3;
// 6. берём значение переменной j=3;
// 7. проверяем 3 < 23 (условие выполняется, переходим к инструкции if);
// 8. выполняем проверку 23 % 3 == 0 это false и мы НЕ выполняем команду перехода на следующую 
// итерацию цикла с меткой notSimple: по директиве continue, а остаёмся во внутреннем цикле и
// увеличиваем значение j на единицу теперь j=4;

// далее аналогично увеличиваем j до 23 и проводим проверку условия i % j == 0. 
// Bсё время мы будем получать значение false  пока при j=23 условие j < i уже не будет выполняться 
// и внутренний цикл проверки числа 23 на наличие кратных делителей будет завершён,
// 9. внутренний цикл перебрал все значения j (от 2 до 23) для переменной i (в данном случае 23)
// и не вернул его по директиве continue на следующую  итерацию цикла с меткой notSimple: 

// И ОПЯТЬ У МЕНЯ ФУНДАМЕНТАЛЬНЫЙ ВОПРОС О ПРИНЦИПЕ РАБОТЫ ЦИКЛА. ПО МОЕМУ МНЕНИЮ (КОТОРОЕ Я ПОШУ
//   ПРОВЕРИТЬ), НА ДАННОМ ЭТАПЕ ЦИКЛ ОКАЗАЛСЯ В СИТУАЦИИ КОГДА ЗНАЧЕНИЕ КОТОРОЕ ОН НАШЁЛ НЕ МОЖЕТ
//    ПРИВЕСТИ К ПЕРЕХОДУ НА СЛЕДУЮЩУЮ ИТЕРАЦИЮ ПО ДИРЕКТИВЕ CONTINUE. И ЕМУ, ДЛЯ ОКОНЧАНИЯ
//     ИТЕРАЦИИ, НУЖНО ПРОЙТИ ПО ДРУГОМУ ПУТИ. В НАШЕЙ ПРОГРАММЕ ЕМУ ДОСТУПЕН ОДИН ПУТЬ - ВЕРНУТЬ
//     НАЙДЕННОЕ ЗНАЧЕНИЕ В console, ТАКИМ ОБРАЗОМ ЗАВЕРШИТЬ ТЕКУЩУЮ ИТЕРАЦИЮ И ПРИСТУПИТЬ К НОВОЙ,
//     И РАБОТАТЬ ДО ТЕХ ПОР ПОКА ВЫПОЛНЯЮТСЯ ВСЕ УСЛОВИЯ ЦИКЛА. И ТОЛЬКО КОГДА ЭТИ УСЛОВИЯ
//   ПЕРЕСТАНУТ ВЫПОЛНЯТЬСЯ ЦИКЛ ЗАВЕРШИТ РАБОТУ (В МОЁМ СЛУЧАЕ ВЫВЕДЕТ В КОНСОЛЬ ВСЕ ПРОСТЫЕ ЧИСЛА 
//   ОТ 20 ДО 100).

// 10. при заданных явных значениях функция вернёт явный результат (на этом этапе это число 23)
// и оно будет передано в console.
// 11. увеличиваем значение переменной і на единицу и теперь і=24;
// 12.  переходим на начало итерации 5.

// ИТЕРАЦИЯ5
// КАК ДЛЯ ЧИСЛА 22 И Т.Д.
