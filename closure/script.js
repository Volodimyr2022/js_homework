let a = 10;
function count () {
    a ++;
    console.log(a);

}
// В этом коде переменная a находится в глобальной области видимости и её значение может некоторым образом измениться и 
// в дальнейшем привести к поломке всей программы.


function createStep(n = 0) {
    let count = n
    return function () {
        count ++;
        console.log(count);

    }
}
// Здесь мы замыкаем (изолируем, заключаем, ув"язнюєм, closure) и переменную n и внутреннюю функцию тем самым меняя их область
// видимости с глобальной на локальную и соответственно полностью исключая к ним доступ из вне. Тем самым мы делаем наш  код
// менее зависимым от случайных ошибок.  

count();
let step1 = createStep();
// Создаём переменную step1 и не указываем никакого аргумента при этом счёт начнётся с 0.

let step2 = createStep(100);
// Создаём переменную step2 и указываем аргумент 100 при этом счёт начнётся со 100.

// Эта особенность позволяет нам использовать одну логику для нескольких счётчиков.
 
step1();
// в результате этого вызова функции мы изменили значение переменной count оно изначально было равно 0, а стало 1. 
// и соответственно мы создали новое лексическое окружение для повторных вызовов функции step1 в котором изменился
// начальный параметр

step1();
// в результате этого вызова функции мы изменили значение переменной count оно изначально было равно 1, а стало 2. 
// и соответственно мы создали новое лексическое окружение для повторных вызовов функции step1 в котором изменился
// начальный параметр и т.д.
// В данном случае наглядно видно правило - ОДИН ВЫЗОВ ОДНО ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ

step2();

function createStep(n = 0) {
    let count = n
    return function () {
        count ++;
        console.log(count);
        const innerFn = () => {
            console.log(a)
        }
        innerFn()
    }
}
let step3 = createStep()
step3()

// А в этом коде я с помощью функции innerFn достучался до внешней переменной. При вызове функции на строке 53 у этой 
// функции создалось лексическое окружение и в этом лексическом окружении не нашлась переменная "а" в Environment Record. 
// Но там нашлась вторая часть лексического окружения ССЫЛКА на внешнее лексическое окружение. Перейдя по этой ссылке во 
// внешнее лексическое окружение JS нашёл переменную "а" в глобальной области видимости (в данном конкретном сдучае)
// и функция вывела её в консоль. А если бы у наc была многоуровневая вложенность то JS вытянул бы нужную переменную с
// того уровня где она находится и передал в нашe функцию innerFn.

Проанализировав Ваш ответ о структуре и порядке выполнения кода, а также подключив полученные знания, жизненный опыт 
и некоторые универсальные философские понятия я для себя сложил наиболее общие понятия процесса написания и выполнения 
кода.

  Самым главным и определяющим успех всего кода является понимание реальной задачи для которой пишется код. 
Затем разрабатывается оптимальная структура программы в соответствии с поставленной задачей и пишутся отдельные 
функции которые принимают в себя некоторые значения обрабатывают их в соответствии со своей логикой и передают результат 
своей работы другим функциям. Занимается этим некий проектант который в своей деятельности руководствуется требованиями заказчика.

    Далее программистам он поручает написать отдельные функции указав в задании какой результат он хочет от них (функций) получить.
Часть функций вспомогательные: это например get запросы или render функции. И их задача подготовить необходимые параметры и внешний облик
 для вывода результата работы функции в которой сосредоточена основная логика. 
И вообще весь процесс написания и выполнения кода это череда функций и их связей между собой то есть ПОЛУЧЕНИЯ УСЛОВИЙ ВЫПОЛНЕНИЯ ФУНКЦИЙ
 и ПЕРЕДАЧИ РЕЗУЛЬТАТА. 

  Так вот написанный правильно код это всё равно нечто спящее или нежизнеспособное я имею в виду сущность из сказок которую окропили 
"мёртвой водой" то есть кости срослись, сухожилия образовались и мышцы появились. Но под жизнью мы имеем в виду философское и биологическое
 понятие, заключающееся в воспроизведениии себе подобных или потомства в общем смысле этого понятия (потомство). 
 Для функции это результат её работы.

    Процесс оживления кода состоит физически (визуально) в передаче аргумента при вызове функции или самом вызове функции, обработки его в
соответствии с установленным сценарием (script-ом) получением результата и передачей его на следущую итерацию. А неочевидно в движке JS
происходит смена лексического окружения функции в момент её вызова. И три понятия: переменная, функция и скрытое свойство [[Environment]] 
приводит код к жизни.  

   В итоге структура кода и ход его выполнения это череда логических действий по получению результата оптимальным способом. И в целом нужно 
включать здравый смысл и логику (например использовать проверенные временем алгоритмы) чтобы правильно писать код.